<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Joan Arnaldich's blog: Posts tagged 'haskell'</title>
  <description>Joan Arnaldich's blog: Posts tagged 'haskell'</description>
  <link>http://www.example.com/tags/haskell.html</link>
  <lastBuildDate>Mon, 16 Dec 2013 00:00:00 CET</lastBuildDate>
  <pubDate>Mon, 16 Dec 2013 00:00:00 CET</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Parallel Voronoi in Haskell</title>
   <link>http://www.example.com/blog/2013/12/16/parallel-voronoi-in-haskell/?utm_source=haskell&amp;utm_medium=RSS</link>
   <guid>urn:http-www-example-com:-blog-2013-12-16-parallel-voronoi-in-haskell</guid>
   <pubDate>Mon, 16 Dec 2013 00:00:00 CET</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.example.com/img/1x1.gif?utm_source=haskell&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2013%2F12%2F16%2Fparallel-voronoi-in-haskell%2F" height="1" width="1" /&gt;
 &lt;p&gt;I recently bought a copy of &lt;em&gt;Parallel and Concurrent Programming in Haskell&lt;/em&gt;, by Simon Marlow, also available online &lt;a href="http://chimera.labs.oreilly.com/books/1230000000929"&gt;here&lt;/a&gt;. It&amp;rsquo;s a very good overview for anyone who (like me) has ever been confused by the wealth of different libraries and primitives for doing concurrency &amp;amp; parallelism in Haskell.&lt;/p&gt;
 &lt;h2 id="Repa"&gt;Repa&lt;/h2&gt;
 &lt;p&gt;A library I found particularly compelling was the &lt;a href="http://hackage.haskell.org/package/repa"&gt;repa&lt;/a&gt;. Quoting from the &lt;a href="http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial"&gt;tutorial&lt;/a&gt;,&lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;Repa is a Haskell library for high performance, regular, multi-dimensional parallel arrays. All numeric data is stored unboxed and functions written with the Repa combinators are automatically parallel...&lt;/p&gt;&lt;/blockquote&gt;
 &lt;p&gt;Let&amp;rsquo;s describe what makes &lt;code&gt;repa&lt;/code&gt; fast step by step. Note that &lt;code&gt;repa&lt;/code&gt; heavily relies on the optimizations performed by the &lt;a href="http://www.haskell.org/ghc/"&gt;GHC&lt;/a&gt;, so whenever I say Haskell in this post, please think of the &lt;code&gt;GHC&lt;/code&gt; stack.&lt;/p&gt;
 &lt;h3 id="Unboxed types"&gt;Unboxed types&lt;/h3&gt;
 &lt;p&gt;Like in many other high-level languages, the default types in GHC are &lt;em&gt;boxed&lt;/em&gt;, meaning that they are represented by a pointer to a object in the heap, rather than a primitive type itself. The use of boxed types adds one level of indirection and thus has an impact on performance because of the extra allocation and the loss of locality.&lt;/p&gt;
 &lt;p&gt;You can read more about unboxed types &lt;a href="http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html"&gt;in the manual&lt;/a&gt;.&lt;/p&gt;
 &lt;h3 id="Stream fusion"&gt;Stream fusion&lt;/h3&gt;
 &lt;p&gt;Consider a function like this:&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;squareAddTwo :: [Int] -&amp;gt; Int
squareAddTwo = sum . map (+2) . map (*3) &lt;/pre&gt;
 &lt;p&gt; It is supposed to multiply each element in an integer list by three, add two, and then sum up all the numbers in the list. A naive implementation of the above would use 3 lists: the input list and two intermediate lists for storing the result of the two &lt;code&gt;map&lt;/code&gt; operations. These intermediate lists are costly in useless temporary allocation and garbage collection.&lt;/p&gt;
 &lt;p&gt;Now, with stream fusion, equational laws are applied to get rid of these intermediate structures in a process called deforestation. The above could be translated into something like:&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;myFoldingSquareAddTwo = foldl' (\x y -&amp;gt; x + (y*3 + 2)) 0&lt;/pre&gt;
 &lt;p&gt; Note that recent versions of GHC have deforestation built-in for regular lists, so you can take advantage of fusion provided you stick to the old suspects: &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, etc... If you implement your own recursive functions, then GHC will &lt;em&gt;not&lt;/em&gt; be able to fuse. Here is a snippet that you can play with. I encourage you to try what is the largest value of &lt;code&gt;n&lt;/code&gt; for which this program correctly terminates:&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;module Main where
import System.Environment
import Data.List (foldl')
    
myMap f [] = []
myMap f (h:t) = f h : myMap f t

mySum [] = 0
mySum (h:t) = h + mySum t

mySquareAddTwo = mySum . myMap  (+2) . myMap (*2) 

squareAddTwo :: [Int] -&amp;gt; Int
squareAddTwo = sum . map (+2) . map (*3) 

myFoldingSquareAddTwo :: [Int] -&amp;gt; Int
myFoldingSquareAddTwo = foldl' (\x y -&amp;gt; x + (y*3 + 2)) 0

main = do
  [n] &amp;lt;- getArgs
  print $ squareAddTwo [1..read n :: Int]
  print $ myFoldingSquareAddTwo [1..read n :: Int]        
  print $ mySquareAddTwo [1..read n :: Int]  &lt;/pre&gt;
 &lt;h3 id="Automatic parallelism"&gt;Automatic parallelism&lt;/h3&gt;
 &lt;p&gt;Repa provides a set of combinators for creating and manipulating arrays. The operations needed to build an array are described declaratively in a first step (creating a so-called &lt;em&gt;delayed&lt;/em&gt; array), and then the array is later materialized (which will give an &lt;em&gt;unboxed&lt;/em&gt; array).&lt;/p&gt;
 &lt;p&gt;This double process allows for &lt;code&gt;repa&lt;/code&gt; not only to fuse away the intermediate structures, but also to perform the required data dependency analysis prior to parallelizing the computation. &lt;/p&gt;
 &lt;p&gt;Hopefully, the Voronoi example will help you understand this process.&lt;/p&gt;
 &lt;h2 id="Voronoi"&gt;Voronoi&lt;/h2&gt;
 &lt;p&gt;Quoting from the &lt;a href="http://en.wikipedia.org/wiki/Voronoi_diagram"&gt;wikipedia&lt;/a&gt;:&lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;In mathematics, a Voronoi diagram is a way of dividing space into a number of regions. A set of points (called seeds, sites, or generators) is specified beforehand and for each seed there will be a corresponding region consisting of all points closer to that seed than to any other. The regions are called Voronoi cells&lt;/p&gt;&lt;/blockquote&gt;
 &lt;p&gt;So we are trying to get a pretty picture like this one:&lt;/p&gt;
 &lt;p&gt;-&amp;gt; &lt;img src="/img/voronoi.png" alt="Voronoi diagram" title="Voronoi diagram" /&gt; &amp;lt;-&lt;/p&gt;
 &lt;h2 id="The Source"&gt;The Source&lt;/h2&gt;
 &lt;pre class="brush: haskell"&gt;&lt;/pre&gt;
 &lt;h2 id="References"&gt;References&lt;/h2&gt;
 &lt;p&gt;asdf&lt;/p&gt;&lt;/html&gt;</description></item>
  <item>
   <title>Haskell Gotchas: Strings</title>
   <link>http://www.example.com/blog/2013/09/09/haskell-gotchas-strings/?utm_source=haskell&amp;utm_medium=RSS</link>
   <guid>urn:http-www-example-com:-blog-2013-09-09-haskell-gotchas-strings</guid>
   <pubDate>Mon, 09 Sep 2013 00:00:00 CET</pubDate>
   <description>
&lt;html&gt;&lt;img src="http://www.example.com/img/1x1.gif?utm_source=haskell&amp;amp;utm_medium=RSS&amp;amp;utm_campaign=%2Fblog%2F2013%2F09%2F09%2Fhaskell-gotchas-strings%2F" height="1" width="1" /&gt;
 &lt;p&gt;I&amp;rsquo;ve been playing with &lt;a href="http://www.haskell.org"&gt;Haskell&lt;/a&gt; on and off for some time now. Let&amp;rsquo;s face it: it&amp;rsquo;s not an easy language to learn. I would agree with most people that part of the difficulty comes from its unique features (laziness, purity, etc...), and the abstractions that derive from them when facing real-world problems (Monads, Iteratees, etc...), but my point here is that there are other sources of confusion that keep misleading beginners like myself and that have nothing to do with all that.&lt;/p&gt;
 &lt;p&gt;In fact, I can see a pattern in those &lt;a href="http://catb.org/~esr/jargon/html/G/gotcha.html"&gt;gotchas&lt;/a&gt;: Haskell often provides several tools for a particular task. It is (too) often the case that the one that&amp;rsquo;s most at hand, or that seems to be favored in the docs, is just not what a newbie would expect. I think this fact has an impact on the perception of first-time users, if they do not perservere enough to seek for alternatives.&lt;/p&gt;
 &lt;p&gt;I am planning to write a series of posts on these gotchas, if only to prevent myself from falling into the same traps the next time I decide to take on Haskell again, and in the hope they will be useful to other learners. Please mind that I have no valorative intetion whatsoever (no flames: it is not a Haskell WTF), and that this is not the work of a seasoned Haskeller: if you find any mistakes in these posts, please report so I can correct them and learn something.&lt;/p&gt;
 &lt;h1 id="Strings"&gt;Strings&lt;/h1&gt;
 &lt;p&gt;This is a paradigmatic case, and probably the reason for many newbies walking away from Haskell wondering how come a compiled language can perform &lt;a href="http://honza.ca/2012/10/haskell-strings"&gt;so much worse&lt;/a&gt; than, say, Python.&lt;/p&gt;
 &lt;p&gt;To recap, Haskell has a &lt;code&gt;String&lt;/code&gt; type. Now, for any non-trivial text processing you can pretty much forget about it. In Haskell, the &lt;code&gt;String&lt;/code&gt; type is defined as a regular list of &lt;code&gt;Char&lt;/code&gt;, and if you&amp;rsquo;ve had some previous exposure to functional lists (with their &lt;code&gt;car&lt;/code&gt;s and &lt;code&gt;cdr&lt;/code&gt;s, &lt;code&gt;head&lt;/code&gt;s and &lt;code&gt;tail&lt;/code&gt;s, ...) you&amp;rsquo;ll know how different a beast they are from the sort of &lt;code&gt;char&lt;/code&gt;/&lt;code&gt;wchar&lt;/code&gt; array most newcomers would expect for a string implementation.&lt;/p&gt;
 &lt;p&gt;Of course, Haskell ships with a bunch of modules designed to work as &lt;code&gt;String&lt;/code&gt; replacements in its standard library. By replacement I mean that the names of the functions are kept consistent so that, if you use qualified imports, it &lt;em&gt;should, in theory&lt;/em&gt; be easy to switch between them. Now, these modules not only change the underlying implementation of a string, but also provide the functions to perform IO according to the type, so they come in &lt;em&gt;strict IO&lt;/em&gt; and &lt;em&gt;lazy IO&lt;/em&gt; flavors: the &lt;em&gt;gotcha&lt;/em&gt; here is that this can dramatically change the &lt;em&gt;semantics&lt;/em&gt; of input/output on the importing module, so switching between them is not always that easy, &lt;em&gt;in practice&lt;/em&gt;.&lt;/p&gt;
 &lt;p&gt;I have deribelately avoided to tackle the subtleties of lazy IO in this post (I may keep that for another gotcha). Take a look at &lt;a href="http://www.haskell.org/haskellwiki/Iteratee_I/O#The_problem_with_lazy_I.2FO"&gt;this&lt;/a&gt; if you can&amp;rsquo;t wait. At the moment, my advice for a newcomer would be to start with the strict versions, because they are closer to the behaviour you&amp;rsquo;d expect in most other languages.&lt;/p&gt;
 &lt;p&gt;If you have already been doing IO in Haskell with &lt;code&gt;Strings&lt;/code&gt; and &lt;code&gt;System.IO&lt;/code&gt;, then you have already been doing &lt;em&gt;lazy&lt;/em&gt; IO, since it&amp;rsquo;s the default. When in doubt, you can always try both and see which one (if any) matches your performance expectations.&lt;/p&gt;
 &lt;h2 id="The Basics"&gt;The Basics&lt;/h2&gt;
 &lt;p&gt;Here&amp;rsquo;s what most Haskellers would recommend:&lt;/p&gt;
 &lt;p&gt;&lt;strong&gt;If you do not care about Unicode&lt;/strong&gt;, use &lt;code&gt;Data.ByteString.Char8&lt;/code&gt;, which is a packed array of &lt;code&gt;Char8&lt;/code&gt; (bytes). The lazy variant is &lt;code&gt;Data.ByteString.Lazy.Char8&lt;/code&gt;. This will be enough if you can assume your input is in (a subset of) &lt;em&gt;latin-1&lt;/em&gt;. &lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;import qualified Data.ByteString.Char8 as B&lt;/pre&gt;
 &lt;p&gt;or&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;import qualified Data.ByteString.Lazy.Char8 as B&lt;/pre&gt;
 &lt;p&gt; &lt;strong&gt;If you care about Unicode&lt;/strong&gt;, go use &lt;code&gt;Data.Text.Text&lt;/code&gt;:&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;import qualified Data.Text as T
import qualified Data.Text.IO as TextIO&lt;/pre&gt;
 &lt;p&gt; or&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;import qualified Data.Text.Lazy as T
import qualified Data.Text.Lazy.IO as TextIO&lt;/pre&gt;
 &lt;p&gt; If you need regular expressions with Unicode, though, the thing gets a little more &lt;a href="http://stackoverflow.com/questions/14922579/haskell-regular-expressions-and-data-text"&gt;involved&lt;/a&gt;.&lt;/p&gt;
 &lt;h2 id="Back and forth"&gt;Back and forth&lt;/h2&gt;
 &lt;p&gt;Even if you use these types, you will still need &lt;code&gt;Prelude.String&lt;/code&gt; in your code: there are a lot of libraries which will expect and return &lt;code&gt;String&lt;/code&gt;s. As an example, the &lt;code&gt;FilePath&lt;/code&gt; type for file and directory manipulation is just an alias for &lt;code&gt;String&lt;/code&gt;. Also, every string literal in your code will be parsed as a &lt;code&gt;String&lt;/code&gt; by default (but see below), so converting from &lt;em&gt;packed&lt;/em&gt; &lt;code&gt;ByteArrays&lt;/code&gt; to &lt;em&gt;unpacked&lt;/em&gt; &lt;code&gt;String&lt;/code&gt;s is achived, not surprisingly, by the functions &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt;. In fact, using &lt;code&gt;String&lt;/code&gt; in your APIs, as long as they&amp;rsquo;re not too large, is one (the only?) sensible use for &lt;code&gt;Strings&lt;/code&gt;.&lt;/p&gt;
 &lt;p&gt;For the &lt;a href="http://www.haskell.org/ghc/"&gt;GHC&lt;/a&gt; stack you can  avoid packing and unpacking string literals by using the &lt;code&gt;OverloadedStrings&lt;/code&gt; pragma. Ie. instead of writing:&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;import qualified Data.Text as T
myFuncExpectingDataText . T.pack $ "Hello World!"&lt;/pre&gt;
 &lt;p&gt; you can add the pragma that makes the call to &lt;code&gt;T.pack&lt;/code&gt; unnecessary:&lt;/p&gt;
 &lt;pre class="brush: haskell"&gt;{-# LANGUAGE OverloadedStrings #-}
import qualified Data.Text as T
myFuncExpectingDataText "Hello World!"&lt;/pre&gt;
 &lt;h2 id="Conclusions"&gt;Conclusions&lt;/h2&gt;
 &lt;p&gt;Here&amp;rsquo;s my piece of advice:&lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;Avoid &lt;code&gt;Prelude.String&lt;/code&gt; for text processing, but bear in mind it is sort of standard when defining your APIs.&lt;/li&gt;
  &lt;li&gt;If you care for Unicode, go for &lt;code&gt;Data.Text&lt;/code&gt;, if the latin-1 subset is enough for you, stick to &lt;code&gt;Data.ByteString&lt;/code&gt;, since regular expressions (and other tasks) are easier there.&lt;/li&gt;
  &lt;li&gt;If you are starting and the performance is enough for your use-case, go for the strict IO. The behaviour is more predictable.&lt;/li&gt;&lt;/ul&gt;
 &lt;p&gt;A final note: this is, by far, not the last word regarding &lt;code&gt;String&lt;/code&gt;s in Haskell. For example, there are abstractions that aim to solve the predictability issues problems of lazy IO while keeping performant (for example, &lt;a href="http://www.haskell.org/haskellwiki/Iteratee_I/O"&gt;Iteratees&lt;/a&gt; or &lt;a href="http://www.haskell.org/haskellwiki/Conduit"&gt;Conduits&lt;/a&gt;. I just think this is the bare minimum to be able to do text-processing in Haskell.&lt;/p&gt;&lt;/html&gt;</description></item></channel></rss>