---
layout: post
title: ROPS v0.1 - Polish Notation Calculator
tags: rops scheme
---

Enough chatter. In this post we will finally see some OCaml code for
our toy Scheme interpreter. We will start with barely more than a
polish notation calculator: our Scheme will only evaluate atoms
(_strings_ _booleans_ and _integers_) and the application of builtin
functions, which will be limited to the arithmetic operators.

Anatomy of a Scheme Interpreter
===============================

Any Scheme interpreter consists of three separated and well-defined
layers:

- The _reader_ takes a stream of characters and returns symbolic
  expressions made up of either atomic objects (in our case booleans,
  integers and strings) or lists.
- The _evaluator_ will interpret the symbolic expressions of the
  reader and produces some result, which are also symbolic
  expressions. This is where most of the fun takes place, because it
  takes care of the _semantics_ of the language. 
- The _printer_ takes the results of the evaluator and prints it to
  some output port.

The _main_ of a typical Scheme interpreter is the _read-eval-print_
loop (_repl_), which will wait for user input and then threads it
through the reader over and over...

The module names in the [repo](https://github.com/jarnaldich/rops)
should be clear by now.

The Evaluator
=============

Most scheme implementation tutorials start with parsing, mainly
because, depending on the implementation language, there is no easy
way to feed objects into the evaluator. As we'll see, it is easy to
get an OCaml repl with the modules needed and try the evaluator
independently of the parsing step. I'd prefer to start with the
evaluator since it makes for a nicer overview of what we are trying to
achive without getting lost in the details yet.

The evaluator takes an parameter of type `scheme_obj` and spits a
variable of the same type. The definition of the `scheme_obj` type can
be found in the file `schemeTypes.ml`. Right now, since whe haven't
yet implemented closures or continuations, the definition for a
`scheme_obj` is equal to the definition of a symbolic expression.
Later on, symbolic expressions will be generated by a strict subset of
the `scheme_obj` type, since some Scheme objects (like closures)
cannot be directly read, but are the result of some evaluation (a
`lambda` form), while every symbolic expression can be a `scheme_obj`
(through quotation, for example).

So the evaluator now deals with a structure like this:

{% highlight ocaml %}
type scheme_obj =
    | Int of int
    | True
    | False
    | String of string
    | Symbol of string
    | List of scheme_obj list
    | DottedList of (scheme_obj list) * scheme_obj;;
{% endhighlight %}

Clearly enough, our Scheme will support strings, symbols, booleans and
integers as atomic data types. We have two kinds of lists, because we
need to be able to separate proper vs improper lists. Remember that
the list type in Scheme is actually a sequence of `cons` cells
pointing tho each other. We could actually define lists through a
`Cons of scheme_obj * scheme_obj` instead of two kinds of lists, but I
want to be able to use the higher-level List functions in OCaml
easily. I will need to be careful in the future so that this
implementation detail is transparent to language users.

{% highlight ocaml %}
open SchemeTypes;;

let rec eval = function
  | List (Symbol "if"::cond::thenc::[elsec]) ->
    (match (eval cond) with
        False -> eval elsec
      | _ -> eval thenc)
  | List (Symbol b::params) ->
    (match Builtins.of_string b with
        Some f -> f (List.map eval params)
      | None -> eval_error "Apply only works with builtins right now.")
  | List _ ->
    eval_error "Apply only works with builtins right now."
  | self_evaluating_obj -> self_evaluating_obj;;
{% endhighlight %}

The code should be self-explanatory. 

Every atom type we have so far is
self-evaluating (ie. the result of evaluating an Int is the Int
itself). 

Then we have function applications, which are now limited to builtin
functions since we still do not have the `lambda` form (that's the
List with a Symbol head branch). In this case we first evaluate params
from left to right throug `List.map` and then call the builtin. The
`Builtin` module is there just to make the code of the evaluator more
compact.

This is the general behaviour of a scheme application, since scheme is
an _applicative order_ language: parameters will be evaluated _before_
applying the function.

A special form is then whatever form that needs to evaluate its params
in different way. The only special form so far is the `if` branch:
depending on the condition evaluation result, only _one_ of the two
branches will be evaluated.

Running it
==========

While we do not have a reader layer, we can play around with the
evaluator by loading the right modules into OCaml's repl. Just load
the right modules by typing the following into the `ocaml` prompt (you
may prefer `rlwrap ocaml` to get it).

{% highlight ocaml %}
#load "schemeTypes.cmo";;
#load "builtins.cmo";;
#load "evaluator.cmo";;
open SchemeTypes;;
open Evaluator;;
{% endhighlight %}

Alternatively, look at the makefile to see how to get a top-level
prompt with the right modules loaded (see the `console` target) so
that you don't have to load them. After that, you'll be ready to test
the evaluator:

{% highlight ocaml %}
eval (List [Symbol "if"; True; Int 1; Int 2]);; (* => 1 *)
eval (List [Symbol "+"; Int 3; Int 1; Int 2]);; (* => 6 *)
{% endhighlight %}

Conclusion
==========

We've set-up the general structure of our Scheme interpreter and
played a little bit with an stripped-down evaluator. In the next post
I'm going to describe the reader level and the repl, so that we can
interact with it in a more "schemely" fashion.

The code is under the branc `v1-rpn-calc` of the [repo](https://github.com/jarnaldich/rops/).
