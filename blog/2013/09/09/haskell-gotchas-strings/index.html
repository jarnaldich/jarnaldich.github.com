<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>Haskell Gotchas: Strings</title>
    <meta name="description" content="I've been playing with Haskell on and off for some time now. Let's face it: it's not an easy language to learn. I would agree with most people that part of the difficulty comes from its unique features (laziness, purity, etc...), and the abstractions that derive from them when facing real-world problems (Monads, Iteratees, etc...), but my point here is that there are other sources of confusion that keep misleading beginners like myself and that have nothing to do with all that. ...">
    <meta name="author"      content="The Unknown Blogger">
    <meta name="keywords"    content="haskell, gotchas, strings">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://www.example.com/blog/2013/09/09/haskell-gotchas-strings/">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pygments.css">
    <link rel="stylesheet" type="text/css" href="/css/scribble.css">
    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <!-- Feeds -->
    <link ref="alternate" type="application/atom+xml"
          href="/feeds/all.atom.xml" title="Atom Feed">
    <link ref="alternate" type="application/rss+xml"
          href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-6838480-2']);
      _gaq.push(['_setDomainName', 'jarnaldich.me']);
      _gaq.push(['_trackPageview']);
      setTimeout(function(){_gaq.push(['_trackEvent', '30_seconds', 'read'])}, 30000); // http://drawingablank.me/blog/fix-your-bounce-rate.html
      (function() {
          var ga = document.createElement('script');
          ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <!-- A standard Twitter Bootstrap nav bar -->
    <header class="navbar navbar-default navbar-inverse"
            role="banner">
      <div class="container">
        <div class="navbar-header">
          <button type="button"
                  class="navbar-toggle"
                  data-toggle="collapse"
                  data-target=".our-nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="/index.html" class="navbar-brand">Joan Arnaldich</a>
        </div>
        <div class="collapse navbar-collapse our-nav-collapse"
             role="navigation">
          <ul class="nav navbar-nav">

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Tags <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="/index.html">All Posts</a></li>

<li><a href="/tags/blogging.html">blogging</a></li>

<li><a href="/tags/concatenative.html">concatenative</a></li>

<li><a href="/tags/factor.html">factor</a></li>

<li><a href="/tags/gotchas.html">gotchas</a></li>

<li><a href="/tags/haskell.html">haskell</a></li>

<li><a href="/tags/jekyll.html">jekyll</a></li>

<li><a href="/tags/lisp.html">lisp</a></li>

<li><a href="/tags/parallel.html">parallel</a></li>

<li><a href="/tags/racket.html">racket</a></li>

<li><a href="/tags/repa.html">repa</a></li>

<li><a href="/tags/scheme.html">scheme</a></li>

<li><a href="/tags/services.html">services</a></li>

<li><a href="/tags/strings.html">strings</a></li>

<li><a href="/tags/voronoi.html">voronoi</a></li>

<li><a href="/tags/win32.html">win32</a></li>
              </ul>
            </li>
            <li>
              <a href="/About.html">About</a>
            </li> 
            <li><a href="/feeds/all.atom.xml">Atom</a></li>
            <li><a href="/feeds/all.rss.xml">RSS</a></li>
          </ul>
        </div>
    </header>
    <div class="container">
      <div class="row">

        <!-- Main column -->
        <div id="left" class="col-md-1"></div>
        <div id="content" class="col-md-10">






<article>

 <header>

  <h1>Haskell Gotchas: Strings</h1>

  <p class="date-and-tags">
   <time datetime="2013-09-09" pubdate="true">2013-09-09</time> :: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/gotchas.html">gotchas</a>, <a href="/tags/strings.html">strings</a></p>
  </header>


 <p>I&rsquo;ve been playing with <a href="http://www.haskell.org">Haskell</a> on and off for some time now. Let&rsquo;s face it: it&rsquo;s not an easy language to learn. I would agree with most people that part of the difficulty comes from its unique features (laziness, purity, etc...), and the abstractions that derive from them when facing real-world problems (Monads, Iteratees, etc...), but my point here is that there are other sources of confusion that keep misleading beginners like myself and that have nothing to do with all that.</p>


 <p>In fact, I can see a pattern in those <a href="http://catb.org/~esr/jargon/html/G/gotcha.html">gotchas</a>: Haskell often provides several tools for a particular task. It is (too) often the case that the one that&rsquo;s most at hand, or that seems to be favored in the docs, is just not what a newbie would expect. I think this fact has an impact on the perception of first-time users, if they do not perservere enough to seek for alternatives.</p>


 <p>I am planning to write a series of posts on these gotchas, if only to prevent myself from falling into the same traps the next time I decide to take on Haskell again, and in the hope they will be useful to other learners. Please mind that I have no valorative intetion whatsoever (no flames: it is not a Haskell WTF), and that this is not the work of a seasoned Haskeller: if you find any mistakes in these posts, please report so I can correct them and learn something.</p>


 <h1 id="Strings">Strings</h1>


 <p>This is a paradigmatic case, and probably the reason for many newbies walking away from Haskell wondering how come a compiled language can perform <a href="http://honza.ca/2012/10/haskell-strings">so much worse</a> than, say, Python.</p>


 <p>To recap, Haskell has a <code>String</code> type. Now, for any non-trivial text processing you can pretty much forget about it. In Haskell, the <code>String</code> type is defined as a regular list of <code>Char</code>, and if you&rsquo;ve had some previous exposure to functional lists (with their <code>car</code>s and <code>cdr</code>s, <code>head</code>s and <code>tail</code>s, ...) you&rsquo;ll know how different a beast they are from the sort of <code>char</code>/<code>wchar</code> array most newcomers would expect for a string implementation.</p>


 <p>Of course, Haskell ships with a bunch of modules designed to work as <code>String</code> replacements in its standard library. By replacement I mean that the names of the functions are kept consistent so that, if you use qualified imports, it <em>should, in theory</em> be easy to switch between them. Now, these modules not only change the underlying implementation of a string, but also provide the functions to perform IO according to the type, so they come in <em>strict IO</em> and <em>lazy IO</em> flavors: the <em>gotcha</em> here is that this can dramatically change the <em>semantics</em> of input/output on the importing module, so switching between them is not always that easy, <em>in practice</em>.</p>


 <p>I have deribelately avoided to tackle the subtleties of lazy IO in this post (I may keep that for another gotcha). Take a look at <a href="http://www.haskell.org/haskellwiki/Iteratee_I/O#The_problem_with_lazy_I.2FO">this</a> if you can&rsquo;t wait. At the moment, my advice for a newcomer would be to start with the strict versions, because they are closer to the behaviour you&rsquo;d expect in most other languages.</p>


 <p>If you have already been doing IO in Haskell with <code>Strings</code> and <code>System.IO</code>, then you have already been doing <em>lazy</em> IO, since it&rsquo;s the default. When in doubt, you can always try both and see which one (if any) matches your performance expectations.</p>


 <h2 id="The Basics">The Basics</h2>


 <p>Here&rsquo;s what most Haskellers would recommend:</p>


 <p><strong>If you do not care about Unicode</strong>, use <code>Data.ByteString.Char8</code>, which is a packed array of <code>Char8</code> (bytes). The lazy variant is <code>Data.ByteString.Lazy.Char8</code>. This will be enough if you can assume your input is in (a subset of) <em>latin-1</em>. </p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Char8</span> <span class="k">as</span> <span class="n">B</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p>or</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy.Char8</span> <span class="k">as</span> <span class="n">B</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> <strong>If you care about Unicode</strong>, go use <code>Data.Text.Text</code>:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text</span> <span class="k">as</span> <span class="n">T</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text.IO</span> <span class="k">as</span> <span class="n">TextIO</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> or</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text.Lazy</span> <span class="k">as</span> <span class="n">T</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text.Lazy.IO</span> <span class="k">as</span> <span class="n">TextIO</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> If you need regular expressions with Unicode, though, the thing gets a little more <a href="http://stackoverflow.com/questions/14922579/haskell-regular-expressions-and-data-text">involved</a>.</p>


 <h2 id="Back and forth">Back and forth</h2>


 <p>Even if you use these types, you will still need <code>Prelude.String</code> in your code: there are a lot of libraries which will expect and return <code>String</code>s. As an example, the <code>FilePath</code> type for file and directory manipulation is just an alias for <code>String</code>. Also, every string literal in your code will be parsed as a <code>String</code> by default (but see below), so converting from <em>packed</em> <code>ByteArrays</code> to <em>unpacked</em> <code>String</code>s is achived, not surprisingly, by the functions <code>pack</code> and <code>unpack</code>. In fact, using <code>String</code> in your APIs, as long as they&rsquo;re not too large, is one (the only?) sensible use for <code>Strings</code>.</p>


 <p>For the <a href="http://www.haskell.org/ghc/">GHC</a> stack you can  avoid packing and unpacking string literals by using the <code>OverloadedStrings</code> pragma. Ie. instead of writing:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text</span> <span class="k">as</span> <span class="n">T</span>
<span class="nf">myFuncExpectingDataText</span> <span class="o">.</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">$</span> <span class="s">"Hello World!"</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> you can add the pragma that makes the call to <code>T.pack</code> unnecessary:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2
3</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="cm">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text</span> <span class="k">as</span> <span class="n">T</span>
<span class="nf">myFuncExpectingDataText</span> <span class="s">"Hello World!"</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <h2 id="Conclusions">Conclusions</h2>


 <p>Here&rsquo;s my piece of advice:</p>


 <ul>

  <li>Avoid <code>Prelude.String</code> for text processing, but bear in mind it is sort of standard when defining your APIs.</li>

  <li>If you care for Unicode, go for <code>Data.Text</code>, if the latin-1 subset is enough for you, stick to <code>Data.ByteString</code>, since regular expressions (and other tasks) are easier there.</li>

  <li>If you are starting and the performance is enough for your use-case, go for the strict IO. The behaviour is more predictable.</li></ul>


 <p>A final note: this is, by far, not the last word regarding <code>String</code>s in Haskell. For example, there are abstractions that aim to solve the predictability issues problems of lazy IO while keeping performant (for example, <a href="http://www.haskell.org/haskellwiki/Iteratee_I/O">Iteratees</a> or <a href="http://www.haskell.org/haskellwiki/Conduit">Conduits</a>. I just think this is the bare minimum to be able to do text-processing in Haskell.</p>

 <footer>

  <script type="text/javascript">
      !function(d,s,id){
          var js,fjs=d.getElementsByTagName(s)[0];
          if(!d.getElementById(id)){
              js=d.createElement(s);
              js.id=id;
              js.src="//platform.twitter.com/widgets.js";
              fjs.parentNode.insertBefore(js,fjs);
          }
      }(document,"script","twitter-wjs");
    </script>
    <a class="twitter-share-button" data-dnt="true" data-url="http://www.example.com/blog/2013/09/09/haskell-gotchas-strings/" href="https://twitter.com/share">
      "Tweet"</a>

  <script src="https://apis.google.com/js/plusone.js" type="text/javascript"></script>

  <g:plusone href="http://www.example.com/blog/2013/09/09/haskell-gotchas-strings/" size="medium"></g:plusone>

  <script type="text/javascript">
      var disqus_shortname = 'jarnaldich';
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>

  <div id="disqus_thread"></div>

  <ul class="pager">

   <li class="previous">
        <a href="/blog/2013/12/16/parallel-voronoi-in-haskell/">&larr; <em>Parallel Voronoi in Haskell</em></a>
      </li>

   <li class="next">
        <a href="/blog/2013/02/24/raw-strings-in-factor/"><em>Raw Strings in Factor </em> &rarr;</a>
      </li>
    </ul>
  </footer>
</article>
        </div>
      </div>
      <div id="right" class="col-md-1"></div>
      <footer>
        <hr />
        <p><a href="https://twitter.com/jarnaldich"
              class="twitter-follow-button"
              data-show-count="false"
              data-lang="en">
             "Follow me on twitter"
           </a>
           <script type="text/javascript">
             !function(d,s,id){
                 var js,fjs=d.getElementsByTagName(s)[0];
                 if(!d.getElementById(id)){
                     js=d.createElement(s);
                     js.id=id;
                     js.src="//platform.twitter.com/widgets.js";
                     fjs.parentNode.insertBefore(js,fjs);
                 }
             }(document,"script","twitter-wjs");
           </script></p>
        <p>Using <a href="https://github.com/greghendershott/frog">Frog</a>,
          <a href="http://twitter.github.com/bootstrap/index.html">Bootstrap</a>
          with an <a href="http://www.bootswatch.com/">alternative CSS.</a></p>
        <p><em>All content
        under  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">attribution,
        noncomertial, sharealike</a> license.</em></p>
      </footer>
    </div>
    <!-- </body> JS -->
    <script type="text/javascript" src="//code.jquery.com/jquery.js"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  </body>
</html>