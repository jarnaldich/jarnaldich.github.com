<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>Parallel Voronoi in Haskell</title>
    <meta name="description" content="I recently bought a copy of _Parallel and Concurrent Programming in Haskell_, by Simon Marlow, also available online here. It's a very good overview for anyone who (like me) has ever been confused by the wealth of different libraries and primitives for doing concurrency & parallelism in Haskell. ...">
    <meta name="author"      content="The Unknown Blogger">
    <meta name="keywords"    content="haskell, voronoi, repa, parallel">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://www.example.com/blog/2013/12/14/parallel-voronoi-in-haskell/">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pygments.css">
    <link rel="stylesheet" type="text/css" href="/css/scribble.css">
    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <!-- Feeds -->
    <link ref="alternate" type="application/atom+xml"
          href="/feeds/all.atom.xml" title="Atom Feed">
    <link ref="alternate" type="application/rss+xml"
          href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-6838480-2']);
      _gaq.push(['_setDomainName', 'jarnaldich.me']);
      _gaq.push(['_trackPageview']);
      setTimeout(function(){_gaq.push(['_trackEvent', '30_seconds', 'read'])}, 30000); // http://drawingablank.me/blog/fix-your-bounce-rate.html
      (function() {
          var ga = document.createElement('script');
          ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <!-- A standard Twitter Bootstrap nav bar -->
    <header class="navbar navbar-default navbar-inverse"
            role="banner">
      <div class="container">
        <div class="navbar-header">
          <button type="button"
                  class="navbar-toggle"
                  data-toggle="collapse"
                  data-target=".our-nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="/index.html" class="navbar-brand">Joan Arnaldich</a>
        </div>
        <div class="collapse navbar-collapse our-nav-collapse"
             role="navigation">
          <ul class="nav navbar-nav">

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Tags <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="/index.html">All Posts</a></li>

<li><a href="/tags/blogging.html">blogging</a></li>

<li><a href="/tags/concatenative.html">concatenative</a></li>

<li><a href="/tags/factor.html">factor</a></li>

<li><a href="/tags/gotchas.html">gotchas</a></li>

<li><a href="/tags/haskell.html">haskell</a></li>

<li><a href="/tags/jekyll.html">jekyll</a></li>

<li><a href="/tags/lisp.html">lisp</a></li>

<li><a href="/tags/parallel.html">parallel</a></li>

<li><a href="/tags/racket.html">racket</a></li>

<li><a href="/tags/repa.html">repa</a></li>

<li><a href="/tags/scheme.html">scheme</a></li>

<li><a href="/tags/services.html">services</a></li>

<li><a href="/tags/strings.html">strings</a></li>

<li><a href="/tags/voronoi.html">voronoi</a></li>

<li><a href="/tags/win32.html">win32</a></li>
              </ul>
            </li>
            <li>
              <a href="/About.html">About</a>
            </li> 
            <li><a href="/feeds/all.atom.xml">Atom</a></li>
            <li><a href="/feeds/all.rss.xml">RSS</a></li>
          </ul>
        </div>
    </header>
    <div class="container">
      <div class="row">

        <!-- Main column -->
        <div id="left" class="col-md-1"></div>
        <div id="content" class="col-md-10">






<article>

 <header>

  <h1>Parallel Voronoi in Haskell</h1>

  <p class="date-and-tags">
   <time datetime="2013-12-14" pubdate="true">2013-12-14</time> :: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/voronoi.html">voronoi</a>, <a href="/tags/repa.html">repa</a>, <a href="/tags/parallel.html">parallel</a></p>
  </header>


 <p>I recently bought a copy of <em>Parallel and Concurrent Programming in Haskell</em>, by Simon Marlow, also available online <a href="http://chimera.labs.oreilly.com/books/1230000000929">here</a>. It&rsquo;s a very good overview for anyone who (like me) has ever been confused by the wealth of different libraries and primitives for doing concurrency &amp; parallelism in Haskell.</p>


 <h2 id="Repa">Repa</h2>


 <p>A library I found particularly compelling was <a href="http://hackage.haskell.org/package/repa">repa</a>. Quoting from the <a href="http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial">tutorial</a>,</p>


 <blockquote>

  <p>Repa is a Haskell library for high performance, regular, multi-dimensional parallel arrays. All numeric data is stored unboxed and functions written with the Repa combinators are automatically parallel...</p></blockquote>


 <p>Let&rsquo;s describe what makes <code>repa</code> fast step by step. Note that <code>repa</code> heavily relies on the optimizations performed by the <a href="http://www.haskell.org/ghc/">GHC</a>, so whenever I say Haskell in this post, please think of the <code>GHC</code> stack.</p>


 <h3 id="Unboxed types">Unboxed types</h3>


 <p>Like in many other high-level languages, the default types in GHC are <em>boxed</em>, meaning that they are represented by a pointer to a object in the heap, rather than a primitive type itself. The use of boxed types adds one level of indirection and thus has an impact on performance because of the extra allocation and the loss of locality.</p>


 <p>You can read more about unboxed types <a href="http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html">in the manual</a>.</p>


 <h3 id="Stream fusion">Stream fusion</h3>


 <p>Consider a function like this:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">squareAddTwo</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">squareAddTwo</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> 
</pre></div>
</td></tr></tbody></table>
</div>


 <p> It is supposed to multiply each element in an integer list by three, add two, and then sum up all the numbers in the list. A naive implementation of the above would use 3 lists: the input list and two intermediate lists for storing the result of the two <code>map</code> operations. These intermediate lists waste time and space doing useless temporary allocation and garbage collection.</p>


 <p>Now, with stream fusion, equational laws are applied to get rid of these intermediate structures in a process called deforestation. The above could be translated into something like:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">myFoldingSquareAddTwo</span> <span class="ow">=</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">0</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> Note that recent versions of GHC have deforestation built-in for regular lists, so you can take advantage of fusion provided you stick to the old suspects: <code>map</code>, <code>fold</code>, etc... If you implement your own recursive functions, then GHC will <em>not</em> be able to fuse. Here is a snippet that you can play with. I encourage you to try what is the largest value of <code>n</code> for which this program correctly terminates:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>
<span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">foldl&#39;</span><span class="p">)</span>

<span class="nf">myMap</span> <span class="n">f</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">myMap</span> <span class="n">f</span> <span class="p">(</span><span class="n">h</span><span class="kt">:</span><span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">h</span> <span class="kt">:</span> <span class="n">myMap</span> <span class="n">f</span> <span class="n">t</span>

<span class="nf">mySum</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">mySum</span> <span class="p">(</span><span class="n">h</span><span class="kt">:</span><span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">mySum</span> <span class="n">t</span>

<span class="nf">mySquareAddTwo</span> <span class="ow">=</span> <span class="n">mySum</span> <span class="o">.</span> <span class="n">myMap</span>  <span class="p">(</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">.</span> <span class="n">myMap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> 

<span class="nf">squareAddTwo</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">squareAddTwo</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> 

<span class="nf">myFoldingSquareAddTwo</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">myFoldingSquareAddTwo</span> <span class="ow">=</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">0</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
  <span class="n">print</span> <span class="o">$</span> <span class="n">squareAddTwo</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">read</span> <span class="n">n</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">]</span>
  <span class="n">print</span> <span class="o">$</span> <span class="n">myFoldingSquareAddTwo</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">read</span> <span class="n">n</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">]</span>        
  <span class="n">print</span> <span class="o">$</span> <span class="n">mySquareAddTwo</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">read</span> <span class="n">n</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">]</span>  
</pre></div>
</td></tr></tbody></table>
</div>


 <h3 id="Automatic parallelism">Automatic parallelism</h3>


 <p>Repa provides a set of combinators for creating and manipulating arrays. The operations needed to build an array are described declaratively in a first step (creating a so-called <em>delayed</em> array), and then the array is later materialized (which will give an <em>unboxed</em> array).</p>


 <p>This double process allows for <code>repa</code> not only to fuse away the intermediate structures, but also to perform the required data dependency analysis prior to parallelizing the computation. </p>


 <p>Hopefully, the Voronoi example will help you understand this process.</p>


 <h2 id="Voronoi">Voronoi</h2>


 <p>Quoting from the <a href="http://en.wikipedia.org/wiki/Voronoi_diagram">wikipedia</a>:</p>


 <blockquote>

  <p>In mathematics, a Voronoi diagram is a way of dividing space into a number of regions. A set of points (called seeds, sites, or generators) is specified beforehand and for each seed there will be a corresponding region consisting of all points closer to that seed than to any other. The regions are called Voronoi cells</p></blockquote>


 <p>So we are trying to get a pretty picture like this one:</p>


 <p><img alt="Voronoi diagram" src="/img/voronoi.png" title="Voronoi diagram" /></p>


 <p>It is a 512x512 images with 150 random centers. The colored polygons represent the areas which are closest to a particular center. The most popular algorithm for computing a Voronoi diagram in 2 dimensions seems to be <a href="http://en.wikipedia.org/wiki/Fortune's_algorithm">Fortune&rsquo;s algorithm</a>. There are also nice open-source implementations out there: for real work, I&rsquo;d recommend the excellent <a href="http://www.qhull.org/html/qvoronoi.htm">qhull library</a>.</p>


 <p>Since I was just interested in testing parallelism, I decided to implement it the <a href="http://rosettacode.org/wiki/Voronoi_diagram">Rosetta Code</a> way, which boils down to just applying the definition: take an image and a random set of in-range pixel coordinates (the centers). For each pixel, color it according to the center that lies closest (in our case, closest according to the euclidean metric). This algorithm is embarassingly naive, but also <a href="http://en.wikipedia.org/wiki/Embarrassingly_parallel">embarassingly parallel</a>, since each pixel can be computed independently.</p>


 <h2 id="The Source">The Source</h2>


 <p>The code is pretty straightforward. You can find the whole source <a href="https://raw.github.com/jarnaldich/jarnaldich.github.com/master/_src/posts/voronoi.hs">here</a>, or on the <a href="http://rosettacode.org/wiki/Voronoi_diagram">Rosetta Code</a> page.</p>


 <p>I&rsquo;ll comment on the most important parts.</p>


 <p>First, we need a function for the metric to minimize. To make it faster, we will not take the square root. We will also use strict annotations and 32 bit unsigned integers (<code>Word32</code>), instead of Haskell&rsquo;s unbounded <code>Int</code>s. Finally, we will tell GHC to inline it, since <code>Repa</code> recommends making extensive use of inlining (as always, when in doubt, profile).</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2
3</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="cm">{-# INLINE sqDistance #-}</span>    
<span class="nf">sqDistance</span> <span class="ow">::</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span>
<span class="nf">sqDistance</span> <span class="o">!</span><span class="n">x1</span> <span class="o">!</span><span class="n">y1</span> <span class="o">!</span><span class="n">x2</span> <span class="o">!</span><span class="n">y2</span> <span class="ow">=</span> <span class="p">((</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> Getting a random array with the centers is easy and shows the way to generate unboxed arrays from a list in <code>repa</code>:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2
3
4
5</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">centers</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM2</span> <span class="kt">Word32</span>
<span class="nf">centers</span> <span class="n">nCenters</span> <span class="n">nCells</span> <span class="ow">=</span>
      <span class="n">fromListUnboxed</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">nCenters</span> <span class="kt">:.</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">$</span> <span class="n">take</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nCenters</span><span class="p">)</span>
    <span class="o">$</span> <span class="n">randomRs</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">nCells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="n">mkStdGen</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> Note the type signature: <code>Array U DIM2 Word32</code> means unboxed array (the <code>U</code>), indexed by 2 integers (the <code>DIM2</code>) and storing <code>Word32</code> values. The indexing is a bit tricky, since is mostly done with the <code>:.</code> operator, and the notation is somewhat overloaded to denote indexes and shapes, so <code>arr Repa.! (Z:. i :. j)</code> means the element in the ith row and jth column of the array arr, but <code>fromListUnboxed (Z :. nCenters :. 2)</code> means we are creating an array of <code>nCenters</code> rows and 2 columns.</p>


 <p>Now there come two helper functions. The first one takes a 2 column matrix and a two parameter function and returns the array resulting of applying the function to each row. </p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2
3</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">applyReduce2</span> <span class="n">arr</span> <span class="n">f</span> <span class="ow">=</span> 
    <span class="n">traverse</span> <span class="n">arr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">i</span> <span class="kt">:.</span> <span class="n">j</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="n">lookup</span> <span class="p">(</span><span class="kt">Z:.</span><span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span>
        <span class="n">f</span> <span class="p">(</span><span class="n">lookup</span> <span class="p">(</span><span class="kt">Z:.</span><span class="n">i</span><span class="kt">:.</span><span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="n">lookup</span> <span class="p">(</span><span class="kt">Z:.</span><span class="n">i</span><span class="kt">:.</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> In order to do so, this function makes use of a very powerful <code>repa</code> combinator, which takes a function on the indices (in this case, reduces one dimension) and a two parameter function. The first parameter is itself a lookup function on the input array, while the second one is the index of the output array whose value we are trying to compute. Please refer to the <a href="http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial">tutorial</a> if this is not clear enough.</p>


 <p>Apart from <code>traverse</code>, there are more familiar combinators, like <code>foldS</code>, which is just like a fold for arrays. We make use of it to compute the minimum of a function over an array. The final <code>S</code> stands for &ldquo;sequential&rdquo;. Some repa combinators come in two flavors: sequential ones or parallel ones (would be <code>foldP</code>). For this algorithm we will parallelize only the pixel loop, so we are using the sequential version for the minimization loop. Here&rsquo;s the minimization function, which basically decorates the array with an index before folding over it:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">minimize1D</span> <span class="n">arr</span> <span class="ow">=</span> <span class="n">foldS</span> <span class="n">f</span> <span class="n">h</span> <span class="n">t</span>
  <span class="kr">where</span>
    <span class="n">indexer</span> <span class="n">src</span> <span class="n">idx</span><span class="o">@</span><span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">src</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">indexed</span> <span class="n">arr</span> <span class="ow">=</span> <span class="n">traverse</span> <span class="n">arr</span> <span class="n">id</span> <span class="n">indexer</span>
    <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">extent</span> <span class="n">arr</span>
    <span class="n">iarr</span> <span class="ow">=</span> <span class="n">indexed</span> <span class="n">arr</span>
    <span class="n">h</span> <span class="ow">=</span> <span class="n">iarr</span> <span class="o">!</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">t</span> <span class="ow">=</span> <span class="n">extract</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="n">iarr</span>
    <span class="n">f</span> <span class="n">min</span><span class="o">@</span><span class="p">(</span><span class="o">!</span><span class="n">valMin</span><span class="p">,</span> <span class="o">!</span><span class="n">iMin</span> <span class="p">)</span> <span class="n">x</span><span class="o">@</span><span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">,</span> <span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">valMin</span> <span class="ow">=</span> <span class="n">x</span>
                                         <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">min</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> With these helpers, writing a parallel voronoi is easy. We will make use of <code>fromFunction</code> to create a <em>delayed</em> array, which we can later force to compute.</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">voronoi</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="kt">DIM2</span> <span class="kt">Word32</span>
<span class="nf">voronoi</span> <span class="n">nCenters</span> <span class="n">nCells</span> <span class="ow">=</span>
    <span class="kr">let</span>
      <span class="n">cellReducer</span> <span class="ow">=</span> <span class="n">applyReduce2</span> <span class="p">(</span><span class="n">centers</span> <span class="n">nCenters</span> <span class="n">nCells</span><span class="p">)</span>
      <span class="n">nearestCenterIndex</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="p">(</span><span class="kt">Repa</span><span class="o">.!</span> <span class="kt">Z</span><span class="p">)</span> <span class="o">.</span> <span class="n">minimize1D</span>
      <span class="cm">{-# INLINE builder #-}</span>
      <span class="n">builder</span> <span class="p">(</span><span class="kt">Z:.</span><span class="n">i</span><span class="kt">:.</span><span class="n">j</span><span class="p">)</span> <span class="ow">=</span> <span class="n">nearestCenterIndex</span>
                        <span class="o">$</span> <span class="n">cellReducer</span> <span class="o">$</span> <span class="n">on</span> <span class="n">sqDistance</span> <span class="n">fromIntegral</span> <span class="n">i</span> <span class="n">j</span>
    <span class="kr">in</span>        
      <span class="kt">Repa</span><span class="o">.</span><span class="n">fromFunction</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">nCells</span> <span class="kt">:.</span> <span class="n">nCells</span> <span class="ow">::</span> <span class="kt">DIM2</span><span class="p">)</span> <span class="n">builder</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> The <code>voronoi</code> function creates a matrix of integer indices, referring to the center which is closest. If we want to write that as an RGB image, we will also need a function to create a random color table and another one to colorize the voronoi array:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2
3
4
5
6
7
8
9</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">genColorTable</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM1</span> <span class="p">(</span><span class="kt">Word8</span><span class="p">,</span> <span class="kt">Word8</span><span class="p">,</span> <span class="kt">Word8</span><span class="p">)</span>
<span class="nf">genColorTable</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fromListUnboxed</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">n</span><span class="p">)</span> <span class="o">$</span> <span class="n">zip3</span> <span class="n">l1</span> <span class="n">l2</span> <span class="n">l3</span>
    <span class="kr">where</span>
      <span class="n">randoms</span> <span class="ow">=</span> <span class="n">randomRs</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">)</span> <span class="p">(</span><span class="n">mkStdGen</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">rest1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="n">n</span> <span class="n">randoms</span>
      <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">rest2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="n">n</span> <span class="n">rest1</span>
      <span class="n">l3</span> <span class="ow">=</span> <span class="n">take</span> <span class="n">n</span> <span class="n">rest2</span>

<span class="nf">colorize</span> <span class="n">ctable</span> <span class="ow">=</span> <span class="kt">Repa</span><span class="o">.</span><span class="n">map</span> <span class="o">$</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">ctable</span> <span class="kt">Repa</span><span class="o">.!</span> <span class="p">(</span><span class="kt">Z:.</span> <span class="n">fromIntegral</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> As we can see, the colorized table will be a two dimensional array of 3-element tuples: one for the red, green, and blue components. This is the format expected by <code>writeImageToBMP</code> in the <code>Repa.IO.BMP</code> package.</p>


 <p>with all the above, the main function will look like:</p>


 <div class="brush: haskell">

  <table class="sourcetable">

   <tbody>

    <tr>

     <td class="linenos">

      <div class="linenodiv">

       <pre>1
2
3
4
5</pre></div></td>

     <td class="code">

      <div class="source">

       <pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">nsites</span> <span class="ow">=</span> <span class="mi">150</span>
  <span class="kr">let</span> <span class="n">ctable</span> <span class="ow">=</span> <span class="n">genColorTable</span> <span class="n">nsites</span> 
  <span class="n">voro</span> <span class="ow">&lt;-</span> <span class="n">computeP</span> <span class="o">$</span> <span class="n">colorize</span> <span class="n">ctable</span> <span class="o">$</span> <span class="n">voronoi</span> <span class="n">nsites</span> <span class="mi">512</span>
  <span class="n">writeImageToBMP</span> <span class="s">"out.bmp"</span> <span class="n">voro</span>
</pre></div>
</td></tr></tbody></table>
</div>


 <p> There are some cool things going on under the hood. First, note that we just plugged the <code>colorize</code> and <code>voronoi</code> parts. In spite of this, there will be no intermediate arrays: both calculations will be fused into a single operation.</p>


 <p>The second thing is the use of a parallel combinator <code>computeP</code>, which will transform a delayed array into an unboxed one <em>in parallel</em> (given the appropiate compilation options and runtime parameters). Note that parallel computations in repa must run in some monad, to ensure they are performed in the appropiate order. It can be any monad (in this case, it&rsquo;s <code>main</code>'s <code>IO</code>).</p>


 <p>Now, if we compile with</p>


 <pre>ghc -O2 -fllvm -fforce-recomp -threaded --make voronoi.hs  -o voronoi</pre>


 <p> My machine is a somewhat oldish 2GHz Intel Core 2 Duo with 4GB (1067Mhz DDR3) of RAM. We can try to run it on one core:</p>


 <pre>$ time ./voronoi

real	0m3.015s
user	0m2.946s
sys	0m0.069s</pre>


 <p> or on two cores:</p>


 <pre>$time ./voronoi +RTS -N2

real	0m1.644s
user	0m3.101s
sys	0m0.068s</pre>


 <p> Note that the speedup is pretty good. We can also see detailed statistics by the runtime system:</p>


 <pre>$ ./voronoi +RTS -N2 -s
   8,750,790,680 bytes allocated in the heap
       5,940,344 bytes copied during GC
         852,168 bytes maximum residency (2 sample(s))
          49,752 bytes maximum slop
               5 MB total memory in use (2 MB lost due to fragmentation)

                                  Tot time (elapsed)  Avg pause  Max pause
Gen  0      8640 colls,  8639 par    0.15s    0.11s     0.0000s    0.0033s
Gen  1         2 colls,     2 par    0.00s    0.00s     0.0003s    0.0005s

  Parallel GC work balance: 1.78 (690765 / 388167, ideal 2)

                        MUT time (elapsed)       GC time  (elapsed)
  Task  0 (worker) :    3.00s    (  1.57s)       0.18s    (  0.13s)
  Task  1 (worker) :    3.18s    (  1.69s)       0.00s    (  0.00s)
  Task  2 (bound)  :    3.18s    (  1.69s)       0.00s    (  0.00s)
  Task  3 (worker) :    2.97s    (  1.54s)       0.21s    (  0.15s)

  SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)

  INIT    time    0.00s  (  0.00s elapsed)
  MUT     time    3.03s  (  1.59s elapsed)
  GC      time    0.15s  (  0.11s elapsed)
  EXIT    time    0.00s  (  0.00s elapsed)
  Total   time    3.18s  (  1.69s elapsed)

  Alloc rate    2,884,832,617 bytes per MUT second

  Productivity  95.3% of total user, 179.1% of total elapsed

gc_alloc_block_sync: 3416
whitehole_spin: 0
gen[0].sync: 0
gen[1].sync: 3</pre>


 <p> 95% user productivity looks good to me. By comparison, and unoptimized single-core <code>C</code> version out of <a href="http://rosettacode.org/wiki/Voronoi_diagram">Rosetta Code</a> takes somewhat less than 2 seconds, while the optimized one takes around half a second.</p>


 <p>Please, take the times above with a grain of salt: I am sure a seasoned haskeller would squeeze more speed out of my version, and probably the <code>C</code> and the Haskell should&rsquo;nt be compared in the first place (the output image format is different).</p>


 <h2 id="Conclusions">Conclusions</h2>


 <p>As we have seen, writing parallel array operations with a decent performance is easy with <code>Repa</code>. While I am doubtful that it can reach the speed of <code>C</code> without making the code just too ugly, IMHO the balance between speed, ease of development and compositional style makes <code>Repa</code> a worthwhile tool in your bag.</p>


 <h2 id="References">References</h2>


 <p>Here are some cool links if you want to play around with Voronoi diagrams:</p>


 <ul>

  <li><a href="http://bl.ocks.org/mbostock/4060366">Online demo</a></li>

  <li><a href="http://www.raymondhill.net/voronoi/rhill-voronoi.html">Another one</a></li>

  <li><a href="http://www.senchalabs.org/philogl/PhiloGL/examples/voronoi/">A spherical one</a></li>

  <li><a href="http://voronoi.com/wiki/index.php?title=Main_Page">The vorowiki</a></li></ul>

 <footer>

  <script type="text/javascript">
      !function(d,s,id){
          var js,fjs=d.getElementsByTagName(s)[0];
          if(!d.getElementById(id)){
              js=d.createElement(s);
              js.id=id;
              js.src="//platform.twitter.com/widgets.js";
              fjs.parentNode.insertBefore(js,fjs);
          }
      }(document,"script","twitter-wjs");
    </script>
    <a class="twitter-share-button" data-dnt="true" data-url="http://www.example.com/blog/2013/12/14/parallel-voronoi-in-haskell/" href="https://twitter.com/share">
      "Tweet"</a>

  <script src="https://apis.google.com/js/plusone.js" type="text/javascript"></script>

  <g:plusone href="http://www.example.com/blog/2013/12/14/parallel-voronoi-in-haskell/" size="medium"></g:plusone>

  <script type="text/javascript">
      var disqus_shortname = 'jarnaldich';
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>

  <div id="disqus_thread"></div>

  <ul class="pager">


   <li class="next">
        <a href="/blog/2013/09/09/haskell-gotchas-strings/"><em>Haskell Gotchas: Strings</em> &rarr;</a>
      </li>
    </ul>
  </footer>
</article>
        </div>
      </div>
      <div id="right" class="col-md-1"></div>
      <footer>
        <hr />
        <p><a href="https://twitter.com/jarnaldich"
              class="twitter-follow-button"
              data-show-count="false"
              data-lang="en">
             "Follow me on twitter"
           </a>
           <script type="text/javascript">
             !function(d,s,id){
                 var js,fjs=d.getElementsByTagName(s)[0];
                 if(!d.getElementById(id)){
                     js=d.createElement(s);
                     js.id=id;
                     js.src="//platform.twitter.com/widgets.js";
                     fjs.parentNode.insertBefore(js,fjs);
                 }
             }(document,"script","twitter-wjs");
           </script></p>
        <p>Using <a href="https://github.com/greghendershott/frog">Frog</a>,
          <a href="http://twitter.github.com/bootstrap/index.html">Bootstrap</a>
          with an <a href="http://www.bootswatch.com/">alternative CSS.</a></p>
        <p><em>All content
        under  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">attribution,
        noncomertial, sharealike</a> license.</em></p>
      </footer>
    </div>
    <!-- </body> JS -->
    <script type="text/javascript" src="//code.jquery.com/jquery.js"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  </body>
</html>